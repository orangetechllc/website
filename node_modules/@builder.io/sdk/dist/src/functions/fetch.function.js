"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var promise_class_1 = __importDefault(require("../classes/promise.class"));
var server_only_require_function_1 = __importDefault(require("./server-only-require.function"));
function promiseResolve(value) {
    return new promise_class_1.default(function (resolve) { return resolve(value); });
}
// Adapted from https://raw.githubusercontent.com/developit/unfetch/master/src/index.mjs
function tinyFetch(url, options) {
    if (options === void 0) { options = {}; }
    return new promise_class_1.default(function (resolve, reject) {
        var request = new XMLHttpRequest();
        request.open(options.method || 'get', url, true);
        if (options.headers) {
            for (var i in options.headers) {
                request.setRequestHeader(i, options.headers[i]);
            }
        }
        request.withCredentials = options.credentials === 'include';
        request.onload = function () {
            resolve(response());
        };
        request.onerror = reject;
        request.send(options.body);
        function response() {
            var keys = [];
            var all = [];
            var headers = {};
            var header = undefined;
            request
                .getAllResponseHeaders()
                .replace(/^(.*?):[^\S\n]*([\s\S]*?)$/gm, function (_match, _key, value) {
                var key = _key;
                keys.push((key = key.toLowerCase()));
                all.push([key, value]);
                header = headers[key];
                headers[key] = header ? header + "," + value : value;
                return '';
            });
            return {
                ok: ((request.status / 100) | 0) === 2,
                status: request.status,
                statusText: request.statusText,
                url: request.responseURL,
                clone: response,
                text: function () { return promiseResolve(request.responseText); },
                json: function () { return promiseResolve(request.responseText).then(JSON.parse); },
                blob: function () { return promiseResolve(new Blob([request.response])); },
                headers: {
                    keys: function () { return keys; },
                    entries: function () { return all; },
                    get: function (n) { return headers[n.toLowerCase()]; },
                    has: function (n) { return n.toLowerCase() in headers; },
                },
            };
        }
    });
}
exports.tinyFetch = tinyFetch;
exports.fetch = typeof global === 'object' && typeof global.fetch === 'function'
    ? global.fetch
    : typeof window === 'undefined'
        ? server_only_require_function_1.default('node-fetch')
        : typeof window.fetch !== 'undefined'
            ? window.fetch
            : tinyFetch;
//# sourceMappingURL=fetch.function.js.map