/// <reference types="@types/node" />
import './polyfills/custom-event-polyfill';
import { IncomingMessage, ServerResponse } from 'http';
import { nextTick } from './functions/next-tick.function';
import { BehaviorSubject } from './classes/observable.class';
import { throttle } from './functions/throttle.function';
import { Animator } from './classes/animator.class';
import { BuilderElement } from './types/element';
import Cookies from './classes/cookies.class';
import { BuilderContent } from './types/content';
export declare type Url = any;
export declare const isReactNative: boolean;
export declare const validEnvList: string[];
export declare const isBrowser: boolean;
export declare const isIframe: boolean;
export interface ParamsMap {
    [key: string]: any;
}
declare type TrackingHook = (eventData: Event, context: {
    content?: BuilderContent;
    [key: string]: any;
}) => Event | undefined;
interface EventData {
    contentId?: string;
    ownerId: string;
    variationId?: string;
    userAttributes?: any;
    targetSelector?: string;
    targetBuilderElement?: string;
    unique?: boolean;
    metadata?: any | string;
    meta?: any | string;
    sessionId?: string;
    visitorId?: string;
    amount?: number;
}
interface Event {
    type: string;
    data: EventData;
}
/**
 * Attributes that can be used for custom targeting. {@link
 * https://www.builder.io/c/docs/guides/targeting-and-scheduling}
 */
export interface UserAttributes {
    [key: string]: undefined | string | string[] | boolean | boolean[] | number | number[] | Record<string, any>;
    /**
     * URL path of the current user.
     */
    urlPath?: string;
    /** @deprecated */
    queryString?: string | ParamsMap;
    /** @deprecated */
    device?: 'mobile' | 'tablet' | 'desktop';
    /** @deprecated */
    location?: any;
    /** @deprecated */
    userAgent?: string;
    /** @deprecated */
    referrer?: string;
    /** @deprecated */
    entryMedium?: string;
    /** @deprecated */
    language?: string;
    /** @deprecated */
    browser?: string;
    /** @deprecated */
    cookie?: string;
    /** @deprecated */
    newVisitor?: boolean;
    /** @deprecated */
    operatingSystem?: string;
}
export interface GetContentOptions {
    userAttributes?: UserAttributes;
    /**
     * Alias for userAttributes.urlPath except it can handle a full URL (optionally with host,
     * protocol, query, etc) and we will parse out the path.
     */
    url?: string;
    /**
     * @package
     */
    includeUrl?: boolean;
    /**
     * Follow references. If you use the `reference` field to pull in other content without this
     * enabled we will not fetch that content for the final response.
     */
    includeRefs?: boolean;
    /**
     * How long in seconds content should be cached for. Sets the max-age of the cache-control header
     * response header.
     *
     * Use a higher value for better performance, lower for content that will change more frequently
     *
     * @see {@link https://www.builder.io/c/docs/query-api#__next:~:text=%26includeRefs%3Dtrue-,cacheSeconds,-No}
     */
    cacheSeconds?: number;
    /**
     * Builder.io uses stale-while-revalidate caching at the CDN level. This means we always serve
     * from edge cache and update caches in the background for maximum possible performance. This also
     * means that the more frequently content is requested, the more fresh it will be. The longest we
     * will ever hold something in stale cache is 1 day by default, and you can set this to be shorter
     * yourself as well. We suggest keeping this high unless you have content that must change rapidly
     * and gets very little traffic.
     *
     * @see {@link https://www.fastly.com/blog/prevent-application-network-instability-serve-stale-content}
     */
    staleCacheSeconds?: number;
    /**
     * Maximum number of results to return. Defaults to `1`.
     */
    limit?: number;
    /**
     * Mongodb style query of your data. E.g.:
     *
     * ```
     * &query.data.id=abc123
     * &query.data.myCustomField=someValue
     * &query.data.someNumber.$ne=20
     * ```
     *
     * See more info on MongoDB's query operators and format.
     *
     * @see {@link https://docs.mongodb.com/manual/reference/operator/query/}
     */
    query?: any;
    /**
     * Bust through all caches. Not recommended for production (for performance),
     * but can be useful for development and static builds (so the static site has
     * fully fresh / up to date content)
     */
    cachebust?: boolean;
    /**
     * Convert any visual builder content to HTML.
     *
     * This will be on data.html of the response's content entry object json.
     */
    prerender?: boolean;
    /**
     * Extract any styles to a separate css property when generating HTML.
     */
    extractCss?: boolean;
    /**
     * Pagination results offset. Defaults to zero.
     */
    offset?: number;
    /**
     * @package
     *
     * `BuilderContent` to render instead of fetching.
     */
    initialContent?: any;
    /**
     * The name of the model to fetch content for.
     */
    model?: string;
    /**
     * Set to `false` to not cache responses when running on the client.
     */
    cache?: boolean;
    /**
     * @package
     *
     * Indicate that the fetch request is for preview purposes.
     */
    preview?: boolean;
    /**
     * Specific content entry ID to fetch.
     */
    entry?: string;
    /**
     * @package
     * @deprecated
     */
    alias?: string;
    fields?: string;
    /**
     * Omit only these fields.
     *
     * @example
     * ```
     * &omit=data.bigField,data.blocks
     * ```
     */
    omit?: string;
    key?: string;
    /**
     * @package
     *
     * Affects HTML generation for specific targets.
     */
    format?: 'amp' | 'email' | 'html' | 'react' | 'solid';
    /** @deprecated */
    noWrap?: true;
    /**
     * @package
     *
     * Specific string to use for cache busting. e.g. every time we generate
     * HTML we generate a rev (a revision ID) and we send that with each request
     * on the client, such that if we generate new server HTML we get a new rev
     * and we use that to bust the cache because even though the content ID may
     * be the same, it could be an updated version of this content that needs to
     * be fresh.
     */
    rev?: string;
    /**
     * @package
     *
     * Tell the API that when generating HTML to generate it in static mode for
     * a/b tests instead of the older way we did this
     */
    static?: boolean;
    /**
     * Additional query params of the Content API to send.
     */
    options?: {
        [key: string]: any;
    };
    /**
     * @package
     *
     * Don't listen to updates in the editor - this is useful for embedded
     * symbols so they don't accidentally listen to messages as you are editing
     * content thinking they should updates when they actually shouldn't.
     */
    noEditorUpdates?: boolean;
}
export declare type Class = {
    name?: string;
    new (...args: any[]): any;
};
interface Map<K, V> {
    clear(): void;
    delete(key: K): boolean;
    entries(): IterableIterator<[K, V]>;
    forEach(callbackfn: (value: V, index: K, map: Map<K, V>) => void, thisArg?: any): void;
    get(key: K): V;
    has(key: K): boolean;
    keys(): IterableIterator<K>;
    set(key: K, value?: V): Map<K, V>;
    size: number;
    values(): IterableIterator<V>;
    [Symbol.iterator](): IterableIterator<[K, V]>;
}
export interface Input {
    name: string;
    friendlyName?: string;
    description?: string;
    defaultValue?: any;
    type: string;
    required?: boolean;
    autoFocus?: boolean;
    subFields?: Input[];
    helperText?: string;
    allowedFileTypes?: string[];
    imageHeight?: number;
    imageWidth?: number;
    mediaHeight?: number;
    mediaWidth?: number;
    hideFromUI?: boolean;
    modelId?: string;
    /**
     * Number field type validation maximum accepted input
     */
    max?: number;
    /**
     * Number field type validation minimum accepted input
     */
    min?: number;
    /**
     * Number field type step size when using arrows
     */
    step?: number;
    /**
     * Set this to `true` to show the editor for this input when
     * children of this component are selected. This is useful for things
     * like Tabs, such that users may not always select the Tabs component
     * directly but will still be looking for how to add additional tabs
     */
    broadcast?: boolean;
    /**
     * Set this to `true` to show the editor for this input when
     * group locked parents of this component are selected. This is useful
     * to bubble up important inputs for locked groups, like text and images
     */
    bubble?: boolean;
    options?: {
        [key: string]: any;
    };
    enum?: string[] | {
        label: string;
        value: any;
        helperText?: string;
    }[];
    /** Regex field validation for all string types (text, longText, html, url, etc) */
    regex?: {
        /** pattern to test, like "^\/[a-z]$" */
        pattern: string;
        /** flags for the RegExp constructor, e.g. "gi"  */
        options?: string;
        /**
         * Friendly message to display to end-users if the regex fails, e.g.
         * "You must use a relative url starting with '/...' "
         */
        message: string;
    };
    advanced?: boolean;
    onChange?: Function | string;
    code?: boolean;
    richText?: boolean;
    showIf?: ((options: Map<string, any>) => boolean) | string;
    copyOnAdd?: boolean;
}
export interface Component {
    /**
     * Name your component something unique, e.g. 'MyButton'. You can override built-in components
     * by registering a component with the same name, e.g. 'Text', to replace the built-in text component
     */
    name: string;
    description?: string;
    /**
     * Link to a documentation page for this component
     */
    docsLink?: string;
    image?: string;
    /**
     * Input schema for your component for users to fill in the options
     */
    inputs?: Input[];
    class?: any;
    type?: 'angular' | 'webcomponent' | 'react' | 'vue';
    defaultStyles?: {
        [key: string]: string;
    };
    /**
     * Turn on if your component can accept children. Be sure to use in combination with
     * withChildren(YourComponent) like here
     * github.com/BuilderIO/builder/blob/master/examples/react-design-system/src/components/HeroWithChildren/HeroWithChildren.builder.js#L5
     */
    canHaveChildren?: boolean;
    fragment?: boolean;
    /**
     * Do not wrap a component in a dom element. Be sure to use {...props.attributes} with this option
     * like here github.com/BuilderIO/builder/blob/master/packages/react/src/blocks/forms/Input.tsx#L34
     */
    noWrap?: boolean;
    /**
     * Default children
     */
    defaultChildren?: BuilderElement[];
    defaults?: Partial<BuilderElement>;
    hooks?: {
        [key: string]: string | Function;
    };
    /**
     * Hide your component in editor, useful for gradually deprecating components
     */
    hideFromInsertMenu?: boolean;
    tag?: string;
    static?: boolean;
    /**
     * Passing a list of model names will restrict using the component to only the models listed here, otherwise it'll be available for all models
     */
    models?: string[];
    /**
     * Specify restrictions direct children must match
     */
    childRequirements?: {
        /** Message to show when this doesn't match, e.g. "Children of 'Columns' must be a 'Column'" */
        message: string;
        /** Simple way to say children must be a specific component name */
        component?: string;
        /**
         * More advanced - specify a MongoDB-style query (using sift.js github.com/crcn/sift.js)
         * of what the children objects should match, e.g.
         *
         * @example
         *  query: {
         *    // Child of this element must be a 'Button' or 'Text' component
         *    'component.name': { $in: ['Button', 'Text'] }
         *  }
         */
        query?: any;
    };
    /**
     * Specify restrictions any parent must match
     */
    requiresParent?: {
        /** Message to show when this doesn't match, e.g. "'Add to cart' buttons must be within a 'Product box'" */
        message: string;
        /** Simple way to say a parent must be a specific component name, e.g. 'Product box' */
        component?: string;
        /**
         * More advanced - specify a MongoDB-style query (using sift.js github.com/crcn/sift.js)
         * of what at least one parent in the parents hierarchy should match, e.g.
         *
         * @example
         *  query: {
         *    // Thils element must be somewhere inside either a 'Product box' or 'Collection' component
         *    'component.name': { $in: ['Product Box', 'Collection'] }
         *  }
         */
        query?: any;
    };
    /** not yet implemented */
    friendlyName?: string;
    /**
     * Use to restrict access to your component based on a the current user permissions
     * By default components will show to all users
     * for more information on permissions in builder check https://www.builder.io/c/docs/guides/roles-and-permissions
     */
    requiredPermissions?: Array<Permission>;
}
declare type Permission = 'read' | 'publish' | 'editCode' | 'editDesigns' | 'admin' | 'create';
declare type DeepPartial<T> = {
    [P in keyof T]?: T[P] extends Array<infer U> ? Array<DeepPartial<U>> : T[P] extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>> : DeepPartial<T[P]>;
};
export interface InsertMenuItem {
    name: string;
    icon?: string;
    item: DeepPartial<BuilderElement>;
}
export interface InsertMenuConfig {
    name: string;
    priority?: number;
    persist?: boolean;
    advanced?: boolean;
    items: InsertMenuItem[];
}
export declare function BuilderComponent(info?: Partial<Component>): (component: Class) => Class;
declare type Settings = any;
export interface Action {
    name: string;
    inputs?: Input[];
    returnType?: Input;
    action: Function | string;
}
export declare class Builder {
    protected request?: IncomingMessage | undefined;
    protected response?: ServerResponse | undefined;
    static VERSION: string;
    static components: Component[];
    static singletonInstance: Builder;
    /**
     * Makes it so that a/b tests generate code like {@link
     * https://www.builder.io/blog/high-performance-no-code#__next:~:text=Static%20generated%20A%2FB%20testing}
     * instead of the old way where we render only one test group at a time on the
     * server. This is the preferred/better way not and we should ultimately make it
     * the default
     */
    static isStatic: boolean;
    static animator: Animator;
    static nextTick: typeof nextTick;
    static throttle: typeof throttle;
    static editors: any[];
    static trustedHosts: string[];
    static plugins: any[];
    static actions: Action[];
    static registry: {
        [key: string]: any[];
    };
    static overrideHost: string | undefined;
    /**
     * @todo `key` property on any info where if a key matches a current
     * key it gets removed
     */
    static register(type: 'insertMenu', info: InsertMenuConfig): void;
    static register(type: string, info: any): void;
    static registryChange: BehaviorSubject<{
        [key: string]: any[];
    }, any>;
    static registerEditor(info: any): void;
    static registerPlugin(info: any): void;
    static registerAction(action: Action): void;
    static registerTrustedHost(host: string): void;
    static isTrustedHost(hostname: string): boolean;
    static runAction(action: Action | string): void;
    static fields(name: string, fields: Input[]): void;
    private static _editingPage;
    static isIframe: boolean;
    static isBrowser: boolean;
    static isReactNative: boolean;
    static isServer: boolean;
    static previewingModel: string | false | null;
    static settings: Settings;
    static settingsChange: BehaviorSubject<any, any>;
    static set(settings: Settings): void;
    static import(packageName: string): any;
    static isEditing: boolean;
    static isPreviewing: boolean;
    static get editingPage(): boolean;
    static set editingPage(editingPage: boolean);
    private static prepareComponentSpecToSend;
    static registerBlock(component: any, options: Component): void;
    static registerComponent(component: any, options: Component): void;
    private static addComponent;
    static component(info?: Partial<Component>): (component: Class) => Class;
    static isReact: boolean;
    static get Component(): typeof Builder.component;
    private eventsQueue;
    private throttledClearEventsQueue;
    private processEventsQueue;
    env: string;
    sessionId: string;
    targetContent: boolean;
    contentPerRequest: number;
    allowCustomFonts: boolean;
    private cookies;
    private cachebust;
    private overrideParams;
    private noCache;
    private preview;
    get browserTrackingDisabled(): boolean;
    get canTrack(): boolean;
    set canTrack(canTrack: boolean);
    private canTrack$;
    private apiKey$;
    private authToken$;
    userAttributesChanged: BehaviorSubject<any, any>;
    get editingMode(): boolean;
    set editingMode(value: boolean);
    editingMode$: BehaviorSubject<boolean, any>;
    get editingModel(): string | null;
    set editingModel(value: string | null);
    private findParentElement;
    private findBuilderParent;
    editingModel$: BehaviorSubject<string | null, any>;
    setUserAgent(userAgent: string): void;
    userAgent: string;
    trackingHooks: TrackingHook[];
    /**
     * Set a hook to modify events being tracked from builder, such as impressions and clicks
     *
     * For example, to track the model ID of each event associated with content for querying
     * by mode, you can do
     *
     *    builder.setTrackingHook((event, context) => {
     *      if (context.content) {
     *        event.data.metadata.modelId = context.content.modelId
     *      }
     *    })
     */
    setTrackingHook(hook: TrackingHook): void;
    track(eventName: string, properties?: Partial<EventData>, context?: any): void;
    getSessionId(): string;
    visitorId: string;
    getVisitorId(): string;
    trackImpression(contentId: string, variationId?: string, properties?: any, context?: any): void;
    trackConversion(amount?: number, customProperties?: any): void;
    autoTrack: boolean;
    private get isDevelopmentEnv();
    trackInteraction(contentId: string, variationId?: string, alreadyTrackedOne?: boolean, event?: MouseEvent, context?: any): void;
    static overrideUserAttributes: Partial<UserAttributes>;
    trackingUserAttributes: {
        [key: string]: any;
    };
    component(info?: Partial<Component>): (component: Class) => Class;
    get apiKey(): string | null;
    set apiKey(key: string | null);
    get authToken(): string | null;
    set authToken(token: string | null);
    constructor(apiKey?: string | null, request?: IncomingMessage | undefined, response?: ServerResponse | undefined, forceNewInstance?: boolean, authToken?: string | null);
    private modifySearch;
    setTestsFromUrl(): void;
    resetOverrides(): void;
    getOverridesFromQueryString(): void;
    private messageFrameLoaded;
    private blockContentLoading;
    private bindMessageListeners;
    observersByKey: {
        [key: string]: BehaviorSubject<BuilderContent[]> | undefined;
    };
    noEditorUpdates: {
        [key: string]: boolean;
    };
    get defaultCanTrack(): boolean;
    init(apiKey: string, canTrack?: boolean, req?: IncomingMessage, res?: ServerResponse, authToken?: string): this;
    get previewingModel(): string;
    getLocation(): Url;
    getUserAttributes(userAgent?: string): UserAttributes;
    protected overrides: {
        [key: string]: string;
    };
    private getContentQueue;
    private priorContentQueue;
    setUserAttributes(options: object): void;
    /**
     * Set user attributes just for tracking purposes.
     *
     * Do this so properties exist on event objects for querying insights, but
     * won't affect targeting
     *
     * Use this when you want to track properties but don't need to target off
     * of them to optimize cache efficiency
     */
    setTrackingUserAttributes(attributes: object): void;
    get(modelName: string, options?: GetContentOptions & {
        req?: IncomingMessage;
        res?: ServerResponse;
        apiKey?: string;
        authToken?: string;
    }): BehaviorSubject<any, any>;
    queueGetContent(modelName: string, options?: GetContentOptions): BehaviorSubject<BuilderContent[], any>;
    requestUrl(url: string, options?: {
        headers: {
            [header: string]: number | string | string[] | undefined;
        };
    }): Promise<any>;
    get host(): string;
    private flushGetContentQueue;
    private testCookiePrefix;
    private processResultsForTests;
    private getTestCookie;
    private cookieQueue;
    private setTestCookie;
    getCookie(name: string): any;
    setCookie(name: string, value: any, expires?: Date): false | void | Cookies;
    getContent(modelName: string, options?: GetContentOptions): BehaviorSubject<BuilderContent[], any>;
    getAll(modelName: string, options?: GetContentOptions & {
        req?: IncomingMessage;
        res?: ServerResponse;
        apiKey?: string;
    }): Promise<BuilderContent[]>;
}
export {};
